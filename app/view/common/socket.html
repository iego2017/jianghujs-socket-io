<script>
  // eslint-disable-next-line strict
  window.socket = {
    client: null,
    online: null,
    loadFinish: false,
    authToken: localStorage.getItem(window.appInfo.appId + "_authToken"),
    deviceId: null,
    packageId: null,
    hasDisconnectOrError: false,
    resource: {
      userNotice: [],
      roomNotice: [],
      userMessage: [],
      roomMessage: [],
      toggleChatSession: [],
      delMessageOffline: [],
      deleteChatSession: [],
      reConnect: [],
    },
    packageListeners: {
    },
    removeListeners: (event, callback) => {
      try {
        const index = socket.resource[event].findIndex(
          (item) => item.name === callback.name
        );
        socket.resource[event].splice(index, 1);
      } catch (err) {
        console.error(err);
      }
    },
    addListeners: (event, callback) => {
      socket.resource[event].push(callback);
    },
    removePackageIdListeners: (packageId) => {
      delete socket.packageListeners[packageId]
    },
    addPackageIdListeners: (packageId, callback) => {
      socket.packageListeners[packageId] = { packageId, callback };
    },
    onReConnect(hasError) {
      socket.resource.reConnect.map((fun) => {
          fun({hasError})
        }
      )
    },
    onResource: (params) => { },
    init: async () => {
      const packageId = `${Date.now()}_${_.random(1000000, 9999999)}`;
      socket.deviceId = localStorage.getItem(`${window.appInfo.appId}_deviceId`);
      const userId = localStorage.getItem(`${window.appInfo.appId}_userId`);
      const socketId = `${socket.deviceId}::${userId}`;
      const requestBody = {
        packageId,
        packageType: "socketRequest",
        deviceId: socket.deviceId,
        status: null,
        timestamp: new Date().toISOString(),
        appData: {
          appId: window.appInfo.appId,
          pageId: "socket",
          actionId: "connect",
          authToken: socket.authToken,
          actionData: {
            socketId,
          },
        },
      };
      try {
        socket.client = io("/", {
          path: `/${window.appInfo.appId}/socket.io`,
          auth: requestBody,
          closeOnBeforeunload: true,
          transports: ["websocket"],
          forceNew: true,
          timeout: 5000,
          secure: false, // 是否支持SSL/TLS
        });
      } catch (e) {
        console.error(e);
      }
      // console.log(' ==== socket init 2')
      socket.createSocketListener();
    },
    // socket 回调
    createSocketListener: () => {
      socket.client.on("resource", async (message) => {
        console.log("==== [socket channel.resource]", JSON.stringify(message));
        // socket.callback('C_IMEVT_COMMON', message);
        const { appId, pageId, actionId } = message.appData;
        socket.packageId = message.packageId;
        //  认证成功
        if (pageId === "socket" && actionId === "connect") {
          // 每次掉线都会重新走一遍认证过程，code=100的逻辑要注意别搞混
          // 设置在线标识
          socket.online = true;
          socket.loadFinish = true;
          console.log("socket.hasDisconnectOrError :: " + socket.hasDisconnectOrError)
          socket.onReConnect(socket.hasDisconnectOrError)
        } else {
          socket.receiveSocketMsg(message.appData, message.packageId);
          if (socket.packageListeners[message.packageId]) {
            const { callback } = socket.packageListeners[message.packageId];
            callback(message);
          }
        }
      });
      socket.client.on("connect", (message) => {
        console.log("==== [socket channel.onConnect]", message);
      });
      socket.client.on("connect_timeout", (message) => {
        console.log("==== [socket channel.connect_timeout]", message);
      });
      socket.client.on("connect_error", (message) => {
        console.log("==== [socket channel.onError]", message);
        socket.hasDisconnectOrError = true;
        socket.online = false;
      });
      socket.client.on("disconnect", (message) => {
        console.log("==== [socket channel.disconnect]", message);
        socket.online = false;
        socket.hasDisconnectOrError = true;
      });
      socket.client.on("reconnect", (message) => {
        socket.hasDisconnectOrError = true;
        console.log("==== [socket channel.onReconnect]", message);
      });
      socket.client.on("reconnect_attempt", (message) => {
        console.log("==== [socket channel.onReconnectAttempt]", message);
      });
      socket.client.on("reconnect_failed", (message) => {
        console.log("==== [socket channel.onReconnectFailed]", message);
      });
      socket.client.on("reconnect_error", (message) => {
        console.log("==== [socket channel.onReconnectError]", message);
      });
      socket.client.on("ping", (message) => {
        // 心跳请求
        // callback_onIMPing
        console.log("==== [socket channel.onPing]", message);
      });
      socket.client.on("pong", (message) => {
        // 心跳响应
        // callback_onIMPong
        console.log("==== [socket channel.onPong]", message);
      });
    },
    // socket消息 分发
    receiveSocketMsg: (appData, packageId) => {
      const { actionData, resultData, actionId } = appData;
      try {
        if (socket.resource[actionId]) {
          socket.resource[actionId].forEach((fun) => {
            fun(resultData || actionData);
          });
        }
      } catch (err) {
        console.error(err);
      }
      const { errorCode, errorReason } = appData;
      if (errorCode) {
        window.vtoast.fail(errorReason);
      }
      // socket.onResource({ params: actionData, actionId, packageId })
      // window.logSocketIn(actionData, packageId);
    },
    // 消息发送
    emitMsg(actionData, actionId) {
      const packageId = `${Date.now()}_${_.random(1000000, 9999999)}`;
      const requestBody = {
        packageId,
        packageType: "socketForward",
        deviceId: socket.deviceId,
        status: null,
        timestamp: new Date().toISOString(),
        appData: {
          appId: window.appInfo.appId,
          pageId: "socket",
          actionId,
          authToken: socket.authToken,
          actionData,
        },
      };
      socket.client.emit("resource", requestBody);
      // window.logSocketOut(window.appInfo.appId, 'socket', actionId, packageId, params);
    },
    // 消息发送
    // {
    //     data: {
    //         appData: {
    //             pageId: 'allPage',
    //             actionId: 'getConstantList',
    //             whereIn: {
    //                 constantKey: ['notice'],
    //             },
    //         }
    //     }
    // }
    emit(path="resource", body) {
      const data = body.data;
      if (!data.appData) { data.appData = {}; }
      const { pageId, actionId } = data.appData;
      const resourceId = `${pageId}.${actionId}`;
      // body 的 数据 优先级更高
      const packageId = `${Date.now()}_${_.random(1000000, 9999999)}`;
      if (!data.packageId) { data.packageId = packageId; }
      const packageType = 'socketForward';
      if (!data.packageType) { data.packageType = packageType; }
      const { appId, userAgent } = window.appInfo;
      if (!data.appData.appId) { data.appData.appId = appId; }
      if (!data.appData.userAgent) { data.appData.userAgent = userAgent; }
      const authToken = localStorage.getItem(`${window.appInfo.appId}_authToken`);
      if (!data.appData.authToken) { data.appData.authToken = authToken; }
      socket.client.emit(path, data);

      if (data.packageType === 'socketRequest') {
        return new Promise((resolve, reject) => {
          let success = false;
          socket.addPackageIdListeners(data.packageId, (responseBody) => {
            success = true;
            console.log("packageIdListeners responseBody", responseBody);
            socket.removePackageIdListeners(data.packageId);
            resolve({ data: responseBody });
          })
          setTimeout(() => {
            if (!success) {
              socket.removePackageIdListeners(data.packageId);
              reject(new Error("请求超时"));
            }
          }, 60000);
        })
      } else {
        return {};
      }
    },
  };

  // 针对 window.socket.online 出现 false 的情况，做定时的检查
  // web 上，进行定时的检查
  if (!window.isApp) {
    setInterval(() => {
      if (!window.socket || !window.socket.client || window.socket.online) {
        return;
      }
      setTimeout(() => {
        if (!window.socket || !window.socket.client || window.socket.online) {
          return;
        }
        console.log(
          "==== [socket window.socket manual reconnect] socket 连续两次检查未连接，则重新连接"
        );
        try {
          window.socket.client.disconnect();
          window.socket.client.connect();
        } catch (err) {
          console.errror(
            "==== [socket window.socket manual reconnect】 socket 重连失败",
            err
          );
        }
      }, 3000);
    }, 5000);
  }
  // app 上，注册 app 重新接入时的检查事件
  window.socket.removeListeners("reConnect", () => {
    setTimeout(() => {
      if (!window.socket || !window.socket.client || window.socket.online) {
        return;
      }
      setTimeout(() => {
        if (!window.socket || !window.socket.client || window.socket.online) {
          return;
        }
        setTimeout(() => {
          if (!window.socket || !window.socket.client || window.socket.online) {
            return;
          }

          console.log(
            "==== [socket window.socket manual reconnect] socket 连续三次检查未连接，则重新连接"
          );
          try {
            window.socket.client.disconnect();
            window.socket.client.connect();
          } catch (err) {
            console.errror(
              "==== [socket window.socket manual reconnect】 socket 重连失败",
              err
            );
          }
        }, 1000);
      }, 1000);
    }, 1000);
  });
</script>
