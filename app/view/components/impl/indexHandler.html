<script>
class IndexHandler {
  // TODO: 有个bug. 如果被移出了房间，获取的列表不会再包含旧房间，所以，房间列表还是包含了已被移出的房间
  // 解决办法：当点击房间的时候，会getRoomInfo, 此时返回您已被移出了房间，
  // 1. 直接全量更新下房间列表（如果房间太多，全量会很慢）
  // 2. 或者UI更新房间列表，并且在缓存中删除房间列表（考虑这种办法，效率高）
  // 获取用户的房间列表
  async getUserRoomRoleListRequest(userId) {
    // 获取缓存列表
    const oldUserRoomRoleList = JSON.parse(localStorage.getItem('userRoomRoleList') || "[]");
    // 获取缓存的更新时间
    let getUserRoomRoleListTime = localStorage.getItem('getUserRoomRoleListTime')
    if (_.isEmpty(oldUserRoomRoleList)) {
      // 缓存列表空的，直接获取全部
      getUserRoomRoleListTime = undefined;
    }
    const result = (await window.jianghuAxios({
      data: {
        appData: {
          pageId: 'chat',
          actionId: 'getUserRoomRoleListService',
          where: {userId, operationAt: getUserRoomRoleListTime}
        }
      }
    })).data.appData.resultData.rows;
    // 更新缓存获取时间
    localStorage.setItem('getUserRoomRoleListTime', new Date().toISOString());
    let newUserRoomRoleList = [];
    // 新旧合并遍历，保留一份最新的
    if (!_.isEmpty(result)) {
      [...oldUserRoomRoleList, ...result].forEach(item => {
        const existIndex = newUserRoomRoleList.findIndex(e => e.roomId === item.roomId);
        if (existIndex > -1) {
          Object.assign(newUserRoomRoleList[existIndex], item);
        } else {
          newUserRoomRoleList.push(item);
        }
      });
      localStorage.setItem('userRoomRoleList', JSON.stringify(newUserRoomRoleList));
    } else {
      newUserRoomRoleList = oldUserRoomRoleList;
    }
    // 缓存最新的列表
    return newUserRoomRoleList;
  }

  // ✅禁止系统菜单和文字选中
  disableSystemEvent(isMobile) {
    document.oncontextmenu = function () {
      event.returnValue =
          !isMobile ||
          (isMobile &&
              (event.target.localName === 'textarea' || event.target.localName === 'input'));
    };
    document.onselectstart = function () {
      event.returnValue =
          !isMobile ||
          (isMobile &&
              (event.target.localName === 'textarea' || event.target.localName === 'input'));
    };
  }

  async syncAppLinkActionConfig() {
    const data = (
        await window.jianghuAxios({
          data: {
            appData: {
              pageId: 'allPage',
              actionId: 'getConstantList',
              whereIn: {
                constantKey: ['appLinkActionConfig']
              }
            }
          }
        })
    ).data.appData.resultData;
    const {rows: constantList} = data;
    if (constantList.length) {
      localStorage.setItem('appLinkActionConfig', constantList[0].constantValue)
    }
  }

  filterByBotList(list, botList) {
    return list.filter(item => {
      const botIncludeChat = botList.some(bot => {
        if (bot.friendId === item.chatId) {
          Object.assign(bot, item);
          return true;
        }
        return false;
      });
      return !botIncludeChat;
    })
  }

  filterBySearchKeyword(list, searchKeyword) {
    return list.filter(v => {
      if (v.chatName && v.chatName.toUpperCase().includes(searchKeyword.toUpperCase())) {
        return true;
      }
      return false;
    })
  }

  sortChatListBackUps(chatListBackUps) {
    return chatListBackUps
        .map(o => {
          let maxTime = o.messageTimeString;
          if (o.topChatOrder && o.topChatOrder.localeCompare(o.messageTimeString) > 0) {
            maxTime = o.topChatOrder;
          }
          o.orderCompare = o.topChatOrder ? 'T' + maxTime : maxTime;
          return o;
        })
        .sort((a, b) => {
          return b.orderCompare.localeCompare(a.orderCompare);
        });
  }
}
</script>
